<!DOCTYPE html><html><head><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lora|Raleway:200"><link rel="stylesheet" href="/main.css"><meta name="viewport" content="initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,width=device-width,height=device-height,target-densitydpi=device-dpi,user-scalable=yes"><title>Remy D'Agostino</title></head><body><main><div class="section"><h1>The Road to Fantasy Land</h1><h2>Sun 15 Jun, 2014</h2></div><article class="post post--blog"><p>I&#39;ve only been developing for the web for two years. When I started I was still deeply in the land of bad C# code with all of it&#39;s <code>InvoiceListDataManager</code> inheriting from <code>ListManipulatorAbstract</code>. I would start new projects with some UML drawing tool just like they taught us at university. I wanted to take this with me to Javascript and I spent most of my energy trying to make object oriented classes work - but I was never happy with it.</p>
<p>When I found Underscore.js I fell in love. I remember reading the documentation, then pitching it to my boss. Grudgingly he accepted the extra 5kb and later that day I used <code>_.chain</code> to form a pipeline for calculating some invoice totals in our app. It felt good; I liked that I was writing less code and using only the abstractions I needed.</p>
<p>It wasn&#39;t perfect. I wanted to use <code>_.chain</code> with other things, but the only way to do that was to <code>_.mixin</code> new functions. Mixins modify underscore globally, I wanted to avoid doing that though because modifying what&#39;s not yours is a quick way to end up in a total maintenance disaster. I played around with <code>_.compose</code> for a bit. That let me put functions in my own modules which seemed to be what I wanted, but <code>_.compose</code> actually doesn&#39;t work well with the standard underscore functions due to the order of their arguments.</p>
<p>I found this super uncomfortable; I started looking for other options. Briefly I went back to the <code>ListHelperManagerSpelunker</code> nonsense, but it was awful. I liked chaining functions together. At this point I came to the conclusion that object oriented programming was all about distributing state over encapsulated, decoupled objects. That might be good for some things but I wanted to get closer to the data I was working with. I wanted everything to be about transforming what you had into a finished product through some sort of pipeline of function calls. In developing a web applications I found myself asking, how do I get from this starting state - a url - into this finished state - a rendered page. I wanted to write as little code as I could because that meant using generic abstractions. If you build everything out of weak generic abstractions like map and reduce then you&#39;ve got code that is easier to reason about because there&#39;s a limited scope to what each function can do.</p>
<p>My experiments here were imperative and honestly not very good. I found <code>_.compose</code> useful for joining some bits of functionality together but I couldn&#39;t get away from big nested if-blocks which forked off in different directions. It seemed easy enough to write a command line utility in this style, but a web-page, with event handing and two way data binding? Yeah - I couldn&#39;t figure that out. </p>
<p>After watching some great presentations by Brian Lonsdorf and doing a little bit of further reading I found out that other people are into this stuff too. They call it functional programming. I&#39;d heard that term before but tried to avoid using it. It sounds like a stupid name, akin to &quot;Intelligent Dance Music&quot; or something. It also seemed like a problem that any language that has &quot;map&quot; or &quot;reduce&quot; gets to say that it is &quot;functional&quot;. The things that Brian was talking about were so much more than &quot;map&quot; or &quot;reduce&quot;; what he was talking about was fantastical. It looked like a completely new and radical way to structure a Javascript application without all of this imperative plumbing crap that I had been writing. I don&#39;t think there has been a time in my life where I was more intrigued by a concept - well, maybe there was, but I&#39;m not sure when. </p>
<p>From there it&#39;s been a crazy and mind-warping road. It is a road fraught with terms like &quot;monad&quot; and &quot;applicative functor&quot;. People say things like &quot;referential transparency&quot; and &quot;side effects&quot;. You can look up those terms if you want, but I promise you that the definitions fail to capture the weight to which these people use them. I&#39;ve had to relearn recursion - which is a terrifying experience. Just coming out of learning recursion is like what I imagine what coming out of the brain-surgery theatre feels like - and I&#39;ve still got so much more to learn.</p>
<p>All the while, I&#39;ve been trying to connect the dots back to my own work in developing web applications. Can monads and applicative functors help you write Javascript code that is easier to reason about than the object oriented stuff?</p>
<p>Does <a href="https://github.com/fantasyland/fantasy-land">fantasy land</a> really exist? I don&#39;t know but I&#39;m going to find out.</p>
</article><div class="endPost"><span>Follow me on&nbsp;</span><a href="http://twitter.com/remydagostino" class="callOut">twitter</a><span>&nbsp;if you want to hear more.</span></div></main><footer><a href="/">Home</a><span>,&nbsp;</span><a href="/blog">Blog</a><span>,&nbsp;</span><a target="_blank" href="http://twitter.com/remydagostino">Tweet</a><span>,&nbsp;</span><a target="_blank" href="https://github.com/remydagostino">Code</a></footer></body></html>